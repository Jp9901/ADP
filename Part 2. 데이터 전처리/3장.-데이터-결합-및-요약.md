### 1절. 데이터 결합

#### 1. rbind

※ 결합하는 데이터들의 열 이름과 개수가 동일해야함.

``` r
customer1 <- data.frame(id = c(1,2,3,4),
                        last_name = c("Lee","Kim","Choi","Park"))

customer2 <- data.frame(id = c(5,6),
                        last_name = c("Lim","Bae"))

id_name <- rbind(customer1,customer2)
id_name
```

    ##   id last_name
    ## 1  1       Lee
    ## 2  2       Kim
    ## 3  3      Choi
    ## 4  4      Park
    ## 5  5       Lim
    ## 6  6       Bae

#### 2. cbind

※ 결합하는 데이터들의 행 개수가 같아야 함.

``` r
custom_age <- data.frame(age = c(49,40,44,25,48,24))
(customer <- cbind(id_name,custom_age))
```

    ##   id last_name age
    ## 1  1       Lee  49
    ## 2  2       Kim  40
    ## 3  3      Choi  44
    ## 4  4      Park  25
    ## 5  5       Lim  48
    ## 6  6       Bae  24

#### 3. merge

``` r
head(id_name)
```

    ##   id last_name
    ## 1  1       Lee
    ## 2  2       Kim
    ## 3  3      Choi
    ## 4  4      Park
    ## 5  5       Lim
    ## 6  6       Bae

``` r
id_number <- data.frame(id = c(4,5,6,7,8),
                        number = c(1,3,2,5,0))
head(id_number)
```

    ##   id number
    ## 1  4      1
    ## 2  5      3
    ## 3  6      2
    ## 4  7      5
    ## 5  8      0

i\. id 칼럼 기준 공통된 값을 가지는 경우만 병합 (데이터 베이스의 Inner
join)

``` r
merge(id_name,id_number,by='id')
```

    ##   id last_name number
    ## 1  4      Park      1
    ## 2  5       Lim      3
    ## 3  6       Bae      2

ii\. id 칼럼 기준 모든 행 병합 (Outer join)

``` r
merge(id_name,id_number,by='id', all = TRUE)
```

    ##   id last_name number
    ## 1  1       Lee     NA
    ## 2  2       Kim     NA
    ## 3  3      Choi     NA
    ## 4  4      Park      1
    ## 5  5       Lim      3
    ## 6  6       Bae      2
    ## 7  7      <NA>      5
    ## 8  8      <NA>      0

iii\. id_name 데이터에 대해서만 id 칼럼 기준 모든 행 병합(Left Outer
Join)

``` r
merge(id_name,id_number,by='id', all.x = TRUE)
```

    ##   id last_name number
    ## 1  1       Lee     NA
    ## 2  2       Kim     NA
    ## 3  3      Choi     NA
    ## 4  4      Park      1
    ## 5  5       Lim      3
    ## 6  6       Bae      2

iv\. id_number 데이터에 대해서만 id 칼럼 기준 모든 행 병합(Right Outer
Join)

``` r
merge(id_name,id_number,by='id', all.y = TRUE)
```

    ##   id last_name number
    ## 1  4      Park      1
    ## 2  5       Lim      3
    ## 3  6       Bae      2
    ## 4  7      <NA>      5
    ## 5  8      <NA>      0

### 2절. 데이터 요약

#### 1. aggregate

: 특정 칼럼을 기준으로 데이터를 그룹지어 집계함수 적용

``` r
aggregate(Sepal.Width~Species, iris, mean)
```

    ##      Species Sepal.Width
    ## 1     setosa       3.428
    ## 2 versicolor       2.770
    ## 3  virginica       2.974

``` r
aggregate(cbind(Sepal.Width, Petal.Width)~Species, iris, mean)
```

    ##      Species Sepal.Width Petal.Width
    ## 1     setosa       3.428       0.246
    ## 2 versicolor       2.770       1.326
    ## 3  virginica       2.974       2.026

#### 2. table

(생략)

#### 3. prob.table

※ prop.table의 인자로는 table 형태의 객체

``` r
data("Titanic")
Titanic <- as.data.frame(Titanic)
str(Titanic)
```

    ## 'data.frame':    32 obs. of  5 variables:
    ##  $ Class   : Factor w/ 4 levels "1st","2nd","3rd",..: 1 2 3 4 1 2 3 4 1 2 ...
    ##  $ Sex     : Factor w/ 2 levels "Male","Female": 1 1 1 1 2 2 2 2 1 1 ...
    ##  $ Age     : Factor w/ 2 levels "Child","Adult": 1 1 1 1 1 1 1 1 2 2 ...
    ##  $ Survived: Factor w/ 2 levels "No","Yes": 1 1 1 1 1 1 1 1 1 1 ...
    ##  $ Freq    : num  0 0 35 0 0 0 17 0 118 154 ...

``` r
head(Titanic)
```

    ##   Class    Sex   Age Survived Freq
    ## 1   1st   Male Child       No    0
    ## 2   2nd   Male Child       No    0
    ## 3   3rd   Male Child       No   35
    ## 4  Crew   Male Child       No    0
    ## 5   1st Female Child       No    0
    ## 6   2nd Female Child       No    0

``` r
prop.table(table(Titanic$Age,Titanic$Survived))
```

    ##        
    ##           No  Yes
    ##   Child 0.25 0.25
    ##   Adult 0.25 0.25

#### 4. subset

-   subset : 조건

-   select : 특정 열

``` r
subset(iris,
       subset = (Species=='setosa' & Sepal.Length>5.5),
       select = c(Species,Sepal.Length))
```

    ##    Species Sepal.Length
    ## 15  setosa          5.8
    ## 16  setosa          5.7
    ## 19  setosa          5.7

### 3절. apply 계열 함수

#### 1. apply

: 데이터의 행/열 방향으로 함수를 적용한 뒤 그 결과를 벡터/배열/리스트로
반환

-   margin : 1 =\> 행 방향, 2 =\> 열 방향

``` r
apply(iris[,1:4],2,mean)
```

    ## Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    ##     5.843333     3.057333     3.758000     1.199333

#### 2. lapply

: 결과를 리스트로 반환

-   X : 벡터, 리스트, 표현식, 데이터프레임

-   FUN : 적용할 함수

``` r
a <- c(1,2,3)
b <- lapply(a, function(x){x^2})
b
```

    ## [[1]]
    ## [1] 1
    ## 
    ## [[2]]
    ## [1] 4
    ## 
    ## [[3]]
    ## [1] 9

``` r
class(b)
```

    ## [1] "list"

``` r
unlist(b)
```

    ## [1] 1 4 9

#### 3. sapply (simplify)

: 결과를 벡터/행렬로 반환

-   simplify=TRUE : TRUE =\> 벡터/행렬로, FALSE =\> 리스트로

``` r
data(iris)
sapply(iris, class) 
```

    ## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
    ##    "numeric"    "numeric"    "numeric"    "numeric"     "factor"

``` r
class(sapply(iris, class)) 
```

    ## [1] "character"

※ simplify=TRUE 여도 simplify가 불가능하면 리스트로 반환

``` r
sapply(iris, summary)
```

    ## $Sepal.Length
    ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    ##   4.300   5.100   5.800   5.843   6.400   7.900 
    ## 
    ## $Sepal.Width
    ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    ##   2.000   2.800   3.000   3.057   3.300   4.400 
    ## 
    ## $Petal.Length
    ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    ##   1.000   1.600   4.350   3.758   5.100   6.900 
    ## 
    ## $Petal.Width
    ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    ##   0.100   0.300   1.300   1.199   1.800   2.500 
    ## 
    ## $Species
    ##     setosa versicolor  virginica 
    ##         50         50         50

``` r
class(sapply(iris, summary))
```

    ## [1] "list"

#### 4. vapply

-   FUN.VALUE : 실행 후 출력되는 값의 형태를 지정

``` r
test <- list(1:100)
test2 <- vapply(test, fivenum, FUN.VALUE = c('Min'=0, 'Q1'=0,"Median"=0, "Q3"=0, "Max"=0))
test2
```

    ##         [,1]
    ## Min      1.0
    ## Q1      25.5
    ## Median  50.5
    ## Q3      75.5
    ## Max    100.0

#### 5. mapply (multivariate)

-   인자n : 함수의 인자

``` r
mapply(rep, c(1:4),c(4:1))
```

    ## [[1]]
    ## [1] 1 1 1 1
    ## 
    ## [[2]]
    ## [1] 2 2 2
    ## 
    ## [[3]]
    ## [1] 3 3
    ## 
    ## [[4]]
    ## [1] 4

#### 6. tapply

: 각 그룹별로 함수 적용

-   INDEX : 데이터를 그룹별로 나누기 위한 기준

``` r
data(iris)
head(iris)
```

    ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
    ## 1          5.1         3.5          1.4         0.2  setosa
    ## 2          4.9         3.0          1.4         0.2  setosa
    ## 3          4.7         3.2          1.3         0.2  setosa
    ## 4          4.6         3.1          1.5         0.2  setosa
    ## 5          5.0         3.6          1.4         0.2  setosa
    ## 6          5.4         3.9          1.7         0.4  setosa

``` r
tapply(iris$Sepal.Length, iris$Species, mean)
```

    ##     setosa versicolor  virginica 
    ##      5.006      5.936      6.588

``` r
tapply(iris$Sepal.Length, iris$Species=='setosa', mean) # setosa인 것과 아닌 것
```

    ## FALSE  TRUE 
    ## 6.262 5.006

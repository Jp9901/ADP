---
title: "4장. 연관분석"
output: html_document
---

### 1절. 연관규칙

#### 1. 연관규칙분석(Association Analysis)의 개념

: 장바구니분석 or 서열분석, 사건들 간의 규칙을 발견하기 위해 적용

#### 2. 연관규칙의 형태

조건과 반응의 형태(IF-THEN)로 이루어짐

#### 3. 연관규칙의 측도

-   지지도(support)

    $$
    지지도 = P(A \cap B) = \frac{A \cap B}{전체}
    $$

-   

    신뢰도(confidence)

    :   연관성의 정도를 파악

    $$
    신뢰도 = \frac{P(A \cap B)}{P(A)} = \frac{지지도}{P(A)}
    $$

-   향상도(Lift)

    $$
    향상도 = \frac{P(A \cap B)}{P(A)P(B)} = \frac{신뢰도}{P(B)}
    $$

=\> A와 B가 서로 관련이 없는 경우 향상도=1

#### 4. Apriori 알고리즘

빈발항목집합 : 최소 지지도보다 큰 지지도 값을 갖는 품목의 집합

빈발항목집합을 찾은 후 그것들에 대해서만 연관규칙 계산

#### 5. R을 이용한 연관분석

as함수(데이터 -\> 트랜젝션 형태) -\> apriori함수(연관분석) -\> inspect함수(연관분석 결과)

-   as(data, class)

    -   data : 데이터 (**factor or logical** 변수)

    -   class : object를 변경할 클래스 이름 (연관분석 =\> '**transactions**')

-   apriori(data, parameter, appearance, control) \# **arules 패키지**

    -   parameter : 최소 지지도(supp), 신뢰도(conf), 최대 아이템 개수(maxlen), 최소 아이템 개수(minlen)

    -   appearance : 특정 연관규칙 결과를 찾을 수 있음

    -   control : 결과 보여주기 등의 알고리즘의 성능을 조정할 수 있음

-   inspect(x,...) \# **arules 패키지**

```{r}
# as함수(데이터 변경) + inspect함수(데이터 확인)

#install.packages('arules')
library(arules)


age <- c('age_20','age_20','age_40','age_30')
rank <- c('Gold','Silver','Silver','VIP')
mobile_app_use <- c('Yes','Yes','No','Yes')

cust_tel <- cbind(age,rank,mobile_app_use)
cust_tel <- as.data.frame(cust_tel)
#cust_tel[,1] <- as.factor(cust_tel[,1])
#cust_tel[,2] <- as.factor(cust_tel[,2])
#cust_tel[,3] <- as.factor(cust_tel[,3])
str(cust_tel)

tran.cust <- as(cust_tel,'transactions')
inspect(tran.cust)
```

```{r}
# apriori
library(arules)

data("Groceries")
Groceries # transactions data
inspect(Groceries[1:3])

groc.rule <- apriori(Groceries,
                     parameter = list(support=0.01,
                                      confidence=0.3))
# => 125 rule(s)개의 연관규칙 생성

inspect(sort(groc.rule,by=c('confidence'),decreasing = T)[1:5])
```

※ confidence가 높다 = 구매 품목들의 연관성이 높다.

※ lift가 높다 = 좌항을 구매할 때, 유항을 구매할 확률이 약 n배 가량 높다.

=\> (좌항-\>우항), (우항-\>좌항)이 겹치는 경우가 있으므로 중복 규칙 제거

```{r}
# 중복가지치기 함수
prune.dup.rules <- function(rules){
  rule.subset.matrix <- is.subset(rules, rules, sparse = FALSE)
  rule.subset.matrix[lower.tri(rule.subset.matrix, diag=T)] <- NA
  dup.rules <- colSums(rule.subset.matrix, na.rm = T) >= 1
  pruned.rules <- rules[!dup.rules]
  return(pruned.rules)
}
```

```{r}
# 특정 우측 값의 연관성 파악
metric.params <- list(supp=0.001, conf=0.5, minlen=2)
groc.rule2 <- apriori(data=Groceries, parameter = metric.params,
                      appearance = list(default='lhs',
                                        rhs='soda'), # 우측='soda'
                      control = list(verbose=F))

groc.rule2 <- prune.dup.rules(groc.rule2) # 중복가지치기
inspect(sort(groc.rule2,by='confidence',decreasing = T)[1:5])
```

```{r}
# 특정 좌측 값의 연관성 파악
metric.params <- list(supp=0.001, conf=0.3, minlen=2)
groc.rule3 <- apriori(data=Groceries, parameter = metric.params,
                      appearance = list(default='rhs',
                                        lhs=c('yogurt','sugar')),
                                        # 좌측=yogurt|sugar
                      control = list(verbose=F))

groc.rule3 <- prune.dup.rules(groc.rule3) # 중복가지치기
inspect(sort(groc.rule3,by='confidence',decreasing = T)[1:5])
```
